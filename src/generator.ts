import type { DMMF } from "@prisma/generator-helper";
import { generatorHandler } from "@prisma/generator-helper";
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";

import { version } from "../package.json";

type Config = {
  name: string;
  prettier: boolean;
  resolvePrettierConfig: boolean;
};

function mapPrismaTypeToZeroType(field: DMMF.Field): string {
  const typeMap: Record<string, string> = {
    String: "string",
    Boolean: "boolean",
    Int: "number",
    Float: "number",
    DateTime: "number", // Zero uses timestamps
    Json: "json",
    BigInt: "number",
    Decimal: "number",
  };

  let output = `${field.name}: `;
  if (field.kind === "enum") {
    output += `enumeration<${field.type}>(${field.isRequired ? "" : "true"})`;
    return output;
  }

  // If it's not an enum, we need to handle required and not required fields differently
  const value = typeMap[field.type] || "string";
  if (field.isRequired) {
    output += `"${value}"`;
  } else {
    output += `{ type: "${value}", optional: true }`;
  }

  return output;
}

function generateRelationships(model: DMMF.Model, dmmf: DMMF.Document) {
  const relationships: string[] = [];

  model.fields
    .filter((field) => field.relationName)
    .forEach((field) => {
      const relName = field.name;
      let sourceField: string;
      let destField: string;

      if (field.isList) {
        // For "many" side relationships, we need to find the matching field in the target model
        // that references back to this model
        const targetModel = dmmf.datamodel.models.find((m) => m.name === field.type);
        const backReference = targetModel?.fields.find(
          (f) => f.relationName === field.relationName && f.type === model.name
        );
        sourceField = "id";
        destField = backReference?.relationFromFields?.[0] || "id";
      } else {
        // For "one" side relationships, use the foreign key
        sourceField = field.relationFromFields?.[0] || "id";
        destField = field.relationToFields?.[0] || "id";
      }

      const destModel = field.type;

      relationships.push(`    ${relName}: {
      sourceField: "${sourceField}",
      destField: "${destField}",
      destSchema: () => ${destModel}Schema,
    }`);
    });

  return relationships.join(",\n");
}

function getTableName(model: DMMF.Model) {
  return model.dbName || model.name;
}

generatorHandler({
  onManifest() {
    return {
      version,
      defaultOutput: "generated/zero",
      prettyName: "Zero Schema",
    };
  },
  async onGenerate(options) {
    const { generator, dmmf } = options;
    const config = {
      name: generator.name,
      prettier: generator.config.prettier === "true", // Default false,
      resolvePrettierConfig: generator.config.resolvePrettierConfig !== "false", // Default true
    } satisfies Config;

    const enums = dmmf.datamodel.enums;
    const models = dmmf.datamodel.models;
    let output = `// Generated by Zero Schema Generator\n\n`;
    output += 'import { createSchema, definePermissions, Row, column } from "@rocicorp/zero";\n\n';
    output += "const { enumeration } = column;\n\n";

    if (enums.length > 0) {
      output += "// Define enums\n\n";
      // Generate enums
      enums.forEach((enumType) => {
        // Generate TypeScript enum
        output += `export enum ${enumType.name} {\n`;
        enumType.values.forEach((value) => {
          // Handle mapped values
          const enumValue = value.dbName || value.name;
          output += `  ${value.name} = "${enumValue}",\n`;
        });
        output += "}\n\n";
      });
    }

    if (models.length > 0) {
      output += "// Define schemas\n\n";
      // Generate schemas for models
      models.forEach((model) => {
        output += `const ${model.name}Schema = {\n`;
        output += `  tableName: "${getTableName(model)}",\n`;
        output += "  columns: {\n";

        model.fields
          .filter((field) => !field.relationName) // Skip relation fields
          .forEach((field) => {
            const fieldValue = mapPrismaTypeToZeroType(field);
            output += `    ${fieldValue},\n`;
          });

        output += "  },\n";

        // Add relationships if any exist
        const relationships = generateRelationships(model, dmmf);
        if (relationships) {
          output += "  relationships: {\n";
          output += relationships;
          output += "\n  },\n";
        }

        // Add primary key
        const primaryKey = model.primaryKey?.name || model.fields.find((f) => f.isId)?.name || "id";
        output += `  primaryKey: "${primaryKey}",\n`;
        output += "} as const;\n\n";
      });
    }

    output += "// Define schema\n\n";
    // Generate the main schema export
    output += "export const schema = createSchema({\n";
    output += "  version: 1,\n";
    output += "  tables: {\n";
    models.forEach((model) => {
      output += `    ${getTableName(model)}: ${model.name}Schema,\n`;
    });
    output += "  },\n";
    output += "});\n\n";

    // Generate types
    output += "// Define types\n";
    output += "export type Schema = typeof schema;\n";
    models.forEach((model) => {
      output += `export type ${model.name} = Row<typeof ${model.name}Schema>;\n`;
    });

    // Add permissions
    output += "\n// Define permissions\n";
    output +=
      "\n// Important: currently no permissions are generated so evey operation is allowed!\n\n";
    output += "\nexport const permissions = definePermissions(schema, () => ({}));\n";

    const outputFile = "schema.ts";
    const outputDir = generator.output?.value;

    if (config.prettier) {
      let prettier: typeof import("prettier");
      try {
        prettier = await import("prettier");
      } catch {
        throw new Error("Unable import Prettier. Is it installed?");
      }

      const prettierOptions = config.resolvePrettierConfig
        ? await prettier.resolveConfig(outputFile)
        : null;

      output = await prettier.format(output, { ...prettierOptions, parser: "typescript" });
    }

    // Ensure output directory exists
    if (outputDir) {
      await mkdir(outputDir, { recursive: true });
    }

    // Write the output to a file
    if (outputDir) {
      await writeFile(join(outputDir, outputFile), output);
    }
  },
});
